import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, z as afterUpdate, t as text, j as claim_text, o as insert_dev, A as set_data_dev, a as detach_dev, e as element, b as space, B as empty, f as claim_element, g as children, h as claim_space, m as add_location, p as append_dev, n as noop, C as binding_callbacks, l as attr_dev, D as add_render_callback, E as add_resize_listener } from './client.a39b1d8a.js';
import { d as d3, g as getGameGroup, t as timeParse, s as sort, a as ascending, b as time, e as extent, l as linear, m as max, f as area, h as basis, i as select, j as axisBottom, k as axisRight, o as ordinal } from './operation.6e105956.js';

/* src/routes/steam-game/DynamicTrend.svelte generated by Svelte v3.35.0 */
const file = "src/routes/steam-game/DynamicTrend.svelte";

// (155:20) {#if data}
function create_if_block_1(ctx) {
	let t0_value = " " + "";
	let t0;
	let t1;
	let t2_value = /*data*/ ctx[0].gamename + "";
	let t2;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = text("of ");
			t2 = text(t2_value);
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, t0_value);
			t1 = claim_text(nodes, "of ");
			t2 = claim_text(nodes, t2_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, t2, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*data*/ 1 && t2_value !== (t2_value = /*data*/ ctx[0].gamename + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(t2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(155:20) {#if data}",
		ctx
	});

	return block;
}

// (166:0) {:else}
function create_else_block(ctx) {
	let div;
	let h3;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			h3 = element("h3");
			t = text("Hover or click on the chart area to see detailed time series");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h3 = claim_element(div_nodes, "H3", {});
			var h3_nodes = children(h3);
			t = claim_text(h3_nodes, "Hover or click on the chart area to see detailed time series");
			h3_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h3, file, 167, 8, 5202);
			attr_dev(div, "class", "hint svelte-vg3v6r");
			add_location(div, file, 166, 4, 5175);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h3);
			append_dev(h3, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(166:0) {:else}",
		ctx
	});

	return block;
}

// (159:0) {#if data}
function create_if_block(ctx) {
	let div;
	let div_resize_listener;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "time-series svelte-vg3v6r");
			add_render_callback(() => /*div_elementresize_handler*/ ctx[6].call(div));
			add_location(div, file, 159, 4, 5002);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			/*div_binding*/ ctx[5](div);
			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[6].bind(div));
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*div_binding*/ ctx[5](null);
			div_resize_listener();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(159:0) {#if data}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let h2;
	let t0;
	let t1;
	let if_block1_anchor;
	let if_block0 = /*data*/ ctx[0] && create_if_block_1(ctx);

	function select_block_type(ctx, dirty) {
		if (/*data*/ ctx[0]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block1 = current_block_type(ctx);

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text("Individual Trend");
			if (if_block0) if_block0.c();
			t1 = space();
			if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", {});
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, "Individual Trend");
			if (if_block0) if_block0.l(h2_nodes);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file, 153, 0, 4903);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t0);
			if (if_block0) if_block0.m(h2, null);
			insert_dev(target, t1, anchor);
			if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (/*data*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(h2, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			if (if_block0) if_block0.d();
			if (detaching) detach_dev(t1);
			if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DynamicTrend", slots, []);
	let timeSeriesEl;
	let timeSeriesWidth;
	let timeSeriesHeight;
	const [marginHorizontal, marginVertical] = [5, 8];
	let { data } = $$props;
	let { rawData } = $$props;

	afterUpdate(() => {
		if (rawData && data) {
			const gameTimeSeries = getGameGroup(rawData).get(data.gamename);

			const gameTimeSeriesDateCasted = gameTimeSeries.map(data => ({
				...data,
				time: timeParse("%B %Y")(`${data.month}${data.year}`),
				avg: +data.avg,
				peak: +data.peak
			}));

			const gameTimeSeriesSorted = sort(gameTimeSeriesDateCasted, (a, b) => ascending(a.time, b.time));
			const x = time().range([0, timeSeriesWidth]).domain(extent(gameTimeSeriesSorted, d => d.time));
			const y = linear().range([timeSeriesHeight, 0]).domain([0, max(gameTimeSeriesSorted, d => d.peak)]);

			const areaAvg = area().curve(basis).x(d => x(d.time)).y0(timeSeriesHeight).y1(d => {
				return y(d.avg);
			});

			const areaMax = area().curve(basis).x(d => x(d.time)).y0(timeSeriesHeight).y1(d => {
				return y(d.peak);
			});

			select(timeSeriesEl).selectAll("svg").remove();

			const chart = select(timeSeriesEl).append("svg").attr("viewBox", [
				0,
				0,
				timeSeriesWidth + marginHorizontal * 2,
				timeSeriesHeight + marginVertical * 2
			]).append("g").attr("transform", `translate(0, 0)`);

			chart.append("path").attr("transform", `translate(0, ${-marginVertical})`).datum(gameTimeSeriesSorted).style("fill", "LightSteelBlue").style("stroke", "LightSteelBlue").attr("d", areaMax);
			chart.append("path").attr("transform", `translate(0, ${-marginVertical})`).datum(gameTimeSeriesSorted).style("fill", "SteelBlue").style("stroke", "SteelBlue").attr("d", areaAvg);
			chart.append("g").attr("transform", `translate(0, ${timeSeriesHeight - marginVertical})`).call(axisBottom(x).tickSizeOuter(0)).style("color", "#f2f2f2");
			chart.append("g").attr("transform", `translate(0, ${-marginVertical})`).call(axisRight(y).tickSizeOuter(0)).style("color", "#f2f2f2").select(".tick").remove();
			const keys = ["Peak", "Average"];
			const color = ordinal().domain(keys).range(["LightSteelBlue", "SteelBlue"]);
			const labelSize = 20;

			chart.selectAll("dots").data(keys).enter().append("rect").attr("x", (d, i) => timeSeriesWidth * 0.5 - (labelSize + 50 * keys.length) * i).attr("y", 0).attr("width", labelSize * 1.2).attr("height", labelSize).style("fill", function (d) {
				return color(d);
			});

			chart.selectAll("labels").data(keys).enter().append("text").attr("x", (d, i) => timeSeriesWidth * 0.5 - (labelSize + 50 * keys.length) * i + labelSize * 1.5).attr("y", labelSize * 0.5).style("fill", function (d) {
				return color(d);
			}).text(function (d) {
				return d;
			}).attr("text-anchor", "right").style("alignment-baseline", "middle");
		}
	});

	const writable_props = ["data", "rawData"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DynamicTrend> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			timeSeriesEl = $$value;
			$$invalidate(1, timeSeriesEl);
		});
	}

	function div_elementresize_handler() {
		timeSeriesWidth = this.clientWidth;
		timeSeriesHeight = this.clientHeight;
		$$invalidate(2, timeSeriesWidth);
		$$invalidate(3, timeSeriesHeight);
	}

	$$self.$$set = $$props => {
		if ("data" in $$props) $$invalidate(0, data = $$props.data);
		if ("rawData" in $$props) $$invalidate(4, rawData = $$props.rawData);
	};

	$$self.$capture_state = () => ({
		d3,
		afterUpdate,
		getGameGroup,
		timeSeriesEl,
		timeSeriesWidth,
		timeSeriesHeight,
		marginHorizontal,
		marginVertical,
		data,
		rawData
	});

	$$self.$inject_state = $$props => {
		if ("timeSeriesEl" in $$props) $$invalidate(1, timeSeriesEl = $$props.timeSeriesEl);
		if ("timeSeriesWidth" in $$props) $$invalidate(2, timeSeriesWidth = $$props.timeSeriesWidth);
		if ("timeSeriesHeight" in $$props) $$invalidate(3, timeSeriesHeight = $$props.timeSeriesHeight);
		if ("data" in $$props) $$invalidate(0, data = $$props.data);
		if ("rawData" in $$props) $$invalidate(4, rawData = $$props.rawData);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		data,
		timeSeriesEl,
		timeSeriesWidth,
		timeSeriesHeight,
		rawData,
		div_binding,
		div_elementresize_handler
	];
}

class DynamicTrend extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { data: 0, rawData: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DynamicTrend",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
			console.warn("<DynamicTrend> was created without expected prop 'data'");
		}

		if (/*rawData*/ ctx[4] === undefined && !("rawData" in props)) {
			console.warn("<DynamicTrend> was created without expected prop 'rawData'");
		}
	}

	get data() {
		throw new Error("<DynamicTrend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<DynamicTrend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rawData() {
		throw new Error("<DynamicTrend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rawData(value) {
		throw new Error("<DynamicTrend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default DynamicTrend;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRHluYW1pY1RyZW5kLmRiZTQzNDY0LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcm91dGVzL3N0ZWFtLWdhbWUvRHluYW1pY1RyZW5kLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbiAgICBpbXBvcnQgeyBhZnRlclVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gICAgaW1wb3J0IHsgZ2V0R2FtZUdyb3VwIH0gZnJvbSAnLi9vcGVyYXRpb24nO1xuXG4gICAgbGV0IHRpbWVTZXJpZXNFbDtcbiAgICBsZXQgdGltZVNlcmllc1dpZHRoO1xuICAgIGxldCB0aW1lU2VyaWVzSGVpZ2h0O1xuXG4gICAgY29uc3QgW21hcmdpbkhvcml6b250YWwsIG1hcmdpblZlcnRpY2FsXSA9IFs1LCA4XTtcblxuICAgIGV4cG9ydCBsZXQgZGF0YTtcbiAgICBleHBvcnQgbGV0IHJhd0RhdGE7XG5cbiAgICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmIChyYXdEYXRhICYmIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGdhbWVUaW1lU2VyaWVzID0gZ2V0R2FtZUdyb3VwKHJhd0RhdGEpLmdldChkYXRhLmdhbWVuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGdhbWVUaW1lU2VyaWVzRGF0ZUNhc3RlZCA9IGdhbWVUaW1lU2VyaWVzLm1hcCgoZGF0YSkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIHRpbWU6IGQzLnRpbWVQYXJzZSgnJUIgJVknKShgJHtkYXRhLm1vbnRofSR7ZGF0YS55ZWFyfWApLFxuICAgICAgICAgICAgICAgIGF2ZzogK2RhdGEuYXZnLFxuICAgICAgICAgICAgICAgIHBlYWs6ICtkYXRhLnBlYWssXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjb25zdCBnYW1lVGltZVNlcmllc1NvcnRlZCA9IGQzLnNvcnQoXG4gICAgICAgICAgICAgICAgZ2FtZVRpbWVTZXJpZXNEYXRlQ2FzdGVkLFxuICAgICAgICAgICAgICAgIChhLCBiKSA9PiBkMy5hc2NlbmRpbmcoYS50aW1lLCBiLnRpbWUpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCB4ID0gZDNcbiAgICAgICAgICAgICAgICAuc2NhbGVUaW1lKClcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHRpbWVTZXJpZXNXaWR0aF0pXG4gICAgICAgICAgICAgICAgLmRvbWFpbihkMy5leHRlbnQoZ2FtZVRpbWVTZXJpZXNTb3J0ZWQsIChkKSA9PiBkLnRpbWUpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBkM1xuICAgICAgICAgICAgICAgIC5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgLnJhbmdlKFt0aW1lU2VyaWVzSGVpZ2h0LCAwXSlcbiAgICAgICAgICAgICAgICAuZG9tYWluKFswLCBkMy5tYXgoZ2FtZVRpbWVTZXJpZXNTb3J0ZWQsIChkKSA9PiBkLnBlYWspXSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFyZWFBdmcgPSBkM1xuICAgICAgICAgICAgICAgIC5hcmVhKClcbiAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcylcbiAgICAgICAgICAgICAgICAueCgoZCkgPT4geChkLnRpbWUpKVxuICAgICAgICAgICAgICAgIC55MCh0aW1lU2VyaWVzSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC55MSgoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geShkLmF2Zyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFyZWFNYXggPSBkM1xuICAgICAgICAgICAgICAgIC5hcmVhKClcbiAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcylcbiAgICAgICAgICAgICAgICAueCgoZCkgPT4geChkLnRpbWUpKVxuICAgICAgICAgICAgICAgIC55MCh0aW1lU2VyaWVzSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC55MSgoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geShkLnBlYWspO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkMy5zZWxlY3QodGltZVNlcmllc0VsKS5zZWxlY3RBbGwoJ3N2ZycpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBjaGFydCA9IGQzXG4gICAgICAgICAgICAgICAgLnNlbGVjdCh0aW1lU2VyaWVzRWwpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgICAgICAuYXR0cigndmlld0JveCcsIFtcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgdGltZVNlcmllc1dpZHRoICsgbWFyZ2luSG9yaXpvbnRhbCAqIDIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVTZXJpZXNIZWlnaHQgKyBtYXJnaW5WZXJ0aWNhbCAqIDIsXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAwKWApO1xuXG4gICAgICAgICAgICBjaGFydFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7LW1hcmdpblZlcnRpY2FsfSlgKVxuICAgICAgICAgICAgICAgIC5kYXR1bShnYW1lVGltZVNlcmllc1NvcnRlZClcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnTGlnaHRTdGVlbEJsdWUnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ0xpZ2h0U3RlZWxCbHVlJylcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGFyZWFNYXgpO1xuXG4gICAgICAgICAgICBjaGFydFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7LW1hcmdpblZlcnRpY2FsfSlgKVxuICAgICAgICAgICAgICAgIC5kYXR1bShnYW1lVGltZVNlcmllc1NvcnRlZClcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnU3RlZWxCbHVlJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdTdGVlbEJsdWUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgYXJlYUF2Zyk7XG5cbiAgICAgICAgICAgIGNoYXJ0XG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoXG4gICAgICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgICAgICAgICAgICAgICBgdHJhbnNsYXRlKDAsICR7dGltZVNlcmllc0hlaWdodCAtIG1hcmdpblZlcnRpY2FsfSlgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5jYWxsKGQzLmF4aXNCb3R0b20oeCkudGlja1NpemVPdXRlcigwKSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2NvbG9yJywgJyNmMmYyZjInKTtcblxuICAgICAgICAgICAgY2hhcnRcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAkey1tYXJnaW5WZXJ0aWNhbH0pYClcbiAgICAgICAgICAgICAgICAuY2FsbChkMy5heGlzUmlnaHQoeSkudGlja1NpemVPdXRlcigwKSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2NvbG9yJywgJyNmMmYyZjInKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJy50aWNrJylcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbJ1BlYWsnLCAnQXZlcmFnZSddO1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBkM1xuICAgICAgICAgICAgICAgIC5zY2FsZU9yZGluYWwoKVxuICAgICAgICAgICAgICAgIC5kb21haW4oa2V5cylcbiAgICAgICAgICAgICAgICAucmFuZ2UoWydMaWdodFN0ZWVsQmx1ZScsICdTdGVlbEJsdWUnXSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGxhYmVsU2l6ZSA9IDIwO1xuXG4gICAgICAgICAgICBjaGFydFxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2RvdHMnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGtleXMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cihcbiAgICAgICAgICAgICAgICAgICAgJ3gnLFxuICAgICAgICAgICAgICAgICAgICAoZCwgaSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVTZXJpZXNXaWR0aCAqIDAuNSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAobGFiZWxTaXplICsgNTAgKiBrZXlzLmxlbmd0aCkgKiBpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBsYWJlbFNpemUgKiAxLjIpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGxhYmVsU2l6ZSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3IoZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNoYXJ0XG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGFiZWxzJylcbiAgICAgICAgICAgICAgICAuZGF0YShrZXlzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoXG4gICAgICAgICAgICAgICAgICAgICd4JyxcbiAgICAgICAgICAgICAgICAgICAgKGQsIGkpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lU2VyaWVzV2lkdGggKiAwLjUgLVxuICAgICAgICAgICAgICAgICAgICAgICAgKGxhYmVsU2l6ZSArIDUwICoga2V5cy5sZW5ndGgpICogaSArXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFNpemUgKiAxLjVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBsYWJlbFNpemUgKiAwLjUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yKGQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAncmlnaHQnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYWxpZ25tZW50LWJhc2VsaW5lJywgJ21pZGRsZScpO1xuICAgICAgICB9XG4gICAgfSk7XG48L3NjcmlwdD5cblxuPGgyPlxuICAgIEluZGl2aWR1YWwgVHJlbmR7I2lmIGRhdGF9XG4gICAgICAgIHsnICd9b2Yge2RhdGEuZ2FtZW5hbWV9XG4gICAgey9pZn1cbjwvaDI+XG57I2lmIGRhdGF9XG4gICAgPGRpdlxuICAgICAgICBiaW5kOnRoaXM9e3RpbWVTZXJpZXNFbH1cbiAgICAgICAgY2xhc3M9XCJ0aW1lLXNlcmllc1wiXG4gICAgICAgIGJpbmQ6Y2xpZW50V2lkdGg9e3RpbWVTZXJpZXNXaWR0aH1cbiAgICAgICAgYmluZDpjbGllbnRIZWlnaHQ9e3RpbWVTZXJpZXNIZWlnaHR9XG4gICAgLz5cbns6ZWxzZX1cbiAgICA8ZGl2IGNsYXNzPVwiaGludFwiPlxuICAgICAgICA8aDM+SG92ZXIgb3IgY2xpY2sgb24gdGhlIGNoYXJ0IGFyZWEgdG8gc2VlIGRldGFpbGVkIHRpbWUgc2VyaWVzPC9oMz5cbiAgICA8L2Rpdj5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICAudGltZS1zZXJpZXMsXG4gICAgLmhpbnQge1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuXG4gICAgLmhpbnQge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgb3BhY2l0eTogMC44O1xuICAgIH1cblxuICAgIC5oaW50IDpnbG9iYWwoaDMpIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOlsiZDMudGltZVBhcnNlIiwiZDMuc29ydCIsImQzLmFzY2VuZGluZyIsImQzLnNjYWxlVGltZSIsImQzLmV4dGVudCIsImQzLnNjYWxlTGluZWFyIiwiZDMubWF4IiwiZDMuYXJlYSIsImQzLmN1cnZlQmFzaXMiLCJkMy5zZWxlY3QiLCJkMy5heGlzQm90dG9tIiwiZDMuYXhpc1JpZ2h0IiwiZDMuc2NhbGVPcmRpbmFsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztnQkEySlMsR0FBRzs7O3lCQUFLLEdBQUksSUFBQyxRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrREFBYixHQUFJLElBQUMsUUFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
